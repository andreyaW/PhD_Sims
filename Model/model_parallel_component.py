"""
model_parallel_component.py

Contains functions to create component objects for the system.py class.


(C) 2023 Regents of the University of Michigan

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


Created on Tues May 30 13:55:00 2020

@author: mdcoll, adware

Last Edited: 30 May 2023 by Andreya Ware (adware)
"""


# ------------------------------------------------------------------------------------------------------------------------------------------------ #    

#import necessary packages
from matplotlib import pyplot as plt
from Model.utils import calculator as calc
from Model.model_series_component import series_comp

import numpy as np

# ------------------------------------------------------------------------------------------------------------------------------------------------ #    
### PARALLEL COMPONENT


class parallel_comp:
    '''

    Class used to create parallel components from series components that have already been initialized
    
    '''

    def __init__(self, parallel_comps, current_system, series_system, count_Prev_Parallels):
        '''
        Initializes a parallel component object with n number of samples in its random failure distrubution.
        
        Parameters
        --------------------------------------------------------------------

        1. parallel_comps: list of integer tuples
                the list of parallel components and their counterparts.
                    EXAMPLE: [(2,3) , (4,5,6)] = components 2 and 3 are parallel with each other 
                                                then components 4,5, and 6 are parallel with each other
        
        2. current_system: list of series or parallel component objects 
            the current system before adding this parallel component, may include series components or 
            parallel components added before this one
            
        3. series system: list of series component objects 
            the system before adding any compoennts in series, useful for referencing a components individual 
            reliability properties
                                               
        3.lookup_times: numpy array of values
            times at which the composite (parallel ) reliability is desired,
            need not be equal to failure times generated by the reliability curves
        
        Returns
        -------------------------------------------------------------------
        1. all_parts_R_t:  stored list of list object with the distrubution of each 
                           component over the designated lookup times       
        '''

        # Labelling Parameters
        self.objName = "System Parallel Component"           # default name of all components (can be changed manually)
        self.assignment = 0                                  # assigned number of the component within the system
        
        # Size and Weight Parameters
        self.weight = 0                                         # Weight of Component         

        # System Architecture Parameters
        self.parallel_parts = parallel_comps                 # list of assignments for objects to consider in parallel
        self.parallel_parts.sort()                           # sort 
        self.num_samples = len(series_system[self.parallel_parts[0]-1].R_t)
        self.series_system = series_system                   # store system as series only components to access for later functions
        self.system =  current_system                        # current system (possibly having parallel parts added)
        self.num_Parallels_added = count_Prev_Parallels     

        # call initialization function which will combine the failure distributions of the parts in parallel
        self.store_elements()
        self.save_all_R_ts()                                                                            


       
    
    def store_elements(self):
        
        # grab info from self
        series_sys = self.series_system
        parallel_assignments = self.parallel_parts
        
        #call function to define name of this parallel part
        self.define_comp_name(parallel_assignments)
               
       # mark the components as added so they can be skipped later
        for assignment in parallel_assignments:
            series_sys[assignment-1].parallel== True
            series_sys[assignment-1].added_in_parallel = True   
        self.series_system = series_sys

        


                
                
    def define_comp_name(self, parallel_list):
        
        # set the name of the part based on which parts are included
        num_parts= len(parallel_list)                  # number of parts in the parallel set
        
        if isinstance(self.series_system[parallel_list[0]], series_comp):
            begin_name= f'Parts '
        else:
            begin_name= f'Groups '
        middle_name= f'{parallel_list[0]}'      
        for i in range(num_parts-1):
            middle_name= middle_name + ',' + f'{parallel_list[i+1]}'
        end_name = f' in Parallel'
    
        name= f'{begin_name + middle_name + end_name}'
        self.objName = name
            
            
        
        
            
                       
    def save_all_R_ts(self):
        
        # grab info from self        
        series_sys = self.series_system
        parallel_assignments = self.parallel_parts
              
        # grab each R_t for the series comps to be considered in parallel
        num_parts = len(parallel_assignments)  
        num_samples = self.num_samples
        series_ts= np.zeros(( num_parts, num_samples ))                          # placeholder for each comp_R_t over lookup
        series_R_ts= np.empty_like(series_ts)
   
        for i, assignment in enumerate(parallel_assignments):
            series_R_ts[i], series_ts[i]= series_sys[assignment-1].R_t , series_sys[assignment-1].t
        
        # determine parallel Reliability   
        self.OR_Logic(series_R_ts, series_ts)                      
        
        # update component weight
        self.calculate_comp_weight()
    
    

    
    def OR_Logic(self, series_R_ts, series_ts):
        '''
        this function will complete the mathematical operations to 
        consider all individual series reliabilites in parallel
                    
                OR Logic
                    - probability of at least one component in parallel still being functional 
                    - (prob comp1 has failed) * (prob comp2 has failed) * (prob comp3 has failed) * ...
                    - (1-R1) * (1-R2) * (1-R3) * ... 
            
        Parameters
        --------------------------------------------------------------------
        1. lookup_times: numpy array of values
            times at which the composite (parallel ) reliability is desired,
            need not be equal to failure times generated by the reliability curves
             
        Returns
        -------------------------------------------------------------------
        1. parallel_R_t:  list of floats
            the calculated overall distrubution of the parallel components over the given lookuptimes    
        '''
        
        # determine final parallel reliability as a probability of all part being failed
        num_samples= self.num_samples
        num_comps = len(self.parallel_parts)

        # save relaibility using or_logic
        finalParallelRel = [1 for val in range(num_samples)]                      # set value equal to 1 at first
        for i in range(num_samples):                                              # iterate through all lookuptimes 
            factor = 1
            for j in range(len(series_R_ts)):                                     # consider all components in parallel set at that lookup time                
                factor *= 1-series_R_ts[j][i]                                     # multiply all component reliabilities
            finalParallelRel[i]= finalParallelRel[i] - factor    
        self.R_t = finalParallelRel

        # save times as the maximum time at each time step / sample point
        parallel_ts = np.zeros((num_samples))
        # index= np.argmax(series_ts, 0)
        for i in range(num_samples):
            # parallel_ts[i] = np.average(series_ts[:,i])
            # parallel_ts[i] = np.avg()
            parallel_ts[i]= np.sum(series_ts[:,i])
        
        self.t = parallel_ts 



    def get_lookup_R_t(self,lookup_times):
        lookup_R_t, lookup_t = calc.find_lookup_R_t(self.R_t, self.t, lookup_times)
        self.lookup_R_t, self.lookup_t=  lookup_R_t, lookup_t





    def determine_average_failure_t(self, mission_length:float = None) : 
        ''' From the random failure times generated, determine the average time of failure of each part
        Args:
            mission_length : the length of time to normalize the average time of failure over
        Returns:
            avg_failure_t: the average time of failure of the system, normalized by mission length if length is provided
        '''

        # determine the failure times at each instance 
        num_parts = len(self.parallel_parts)  
        num_samples = self.num_samples
        all_fails = np.zeros(( num_parts, num_samples ))

        # store the failure times of each part over all samples
        for i in range(num_parts): 
            part = self.series_system[self.parallel_parts[i]-1]
            if isinstance(part, series_comp):
                all_fails[i] = part.random_fail_times
            else:
                all_fails[i] = part.t
                
        total_time = 0
        all_fails = all_fails.T
        for fails in all_fails:
            total_time += max(fails)
        avg_failure_t= total_time / all_fails.shape[0]

        # normalize time if mission length is provided
        if mission_length != None: 
            avg_failure_t = avg_failure_t / mission_length

        # store the failure time to self
        self.avg_fail_time = avg_failure_t

        return avg_failure_t


    def calculate_comp_weight(self):
        total_weight = self.weight
        for assignment in self.parallel_parts:
            total_weight += self.series_system[assignment-1].weight     
            # print('parallel weight', total_weight)




    """  
    def determine_Failure_T(self, num_realization):
        '''
        Parameters
        -------------------------------------------------------------------
        1.) num_realization: 
            the "failure instance" or "vessel number" to select from the randomly generated
            distribution of serial component failure times . 

        Return
        -------------------------------------------------------------------
        1.) fail_time: 
            the time of failure for the instance requested        
        '''
        
        parts= self.parallel_parts
        series_sys= self.series_system

        fail_times= [0 for i in range(len(parts))]
                
        # grab the failure time of the part in the parallel set 
        for i, comp_assignment in enumerate(parts):
            
            # grab a failure realization from the original random distribution
            series_comp= series_sys[comp_assignment-1]
            series_comp.determine_failure_t(num_realization)
            fail_times[i] = series_comp.f_t

        # determine which part fails last
        parallel_f_t= max(fail_times)
        
        self.f_t = parallel_f_t
    """