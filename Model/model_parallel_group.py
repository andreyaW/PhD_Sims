"""
model_parallel_group.py

Contains functions to create component objects for the system.py class.


(C) 2023 Regents of the University of Michigan

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


Created on Tues May 30 13:55:00 2020

@author: mdcoll, adware

Last Edited: 30 May 2023 by Andreya Ware (adware)
"""


# ------------------------------------------------------------------------------------------------------------------------------------------------ #    

#import necessary packages
from matplotlib import pyplot as plt
from Model.utils import calculator as calc
import scipy.stats as sp
import numpy as np
import copy

# ------------------------------------------------------------------------------------------------------------------------------------------------ #    
### PARALLEL COMPONENT


class parallel_group:

    def __init__(self, parallel_group_assignments: list[tuple], current_system, series_system, count_Prev_Parallels):
        ''' Class used to create parallel groups from series groups that have already been initialized
        Args
        parallel_comps: the list of parallel components and their counterparts.
                        EXAMPLE: [(2,3) , (4,5,6)] = components 2 and 3 are parallel with each other 
                                                     then components 4,5, and 6 are parallel with each other

        current_system :  the current system before adding this parallel component, may include series components
                          or parallel components added before this one

        series system: the system before adding any compoennts in series, useful for referencing a components or groups 
                       individual reliability properties
                                               
        3.lookup_times: numpy array of values
            times at which the composite (parallel ) reliability is desired,
            need not be equal to failure times generated by the reliability curves
        
        Returns
        -------------------------------------------------------------------
        1. all_parts_R_t:  stored list of list object with the distrubution of each 
                           component over the designated lookup times       
        '''
        self.assignment = 0                                  # assigned number of the component within the system
        
        self.parallel_parts = parallel_comps                 # list of assignments for objects to consider in parallel
        self.parallel_parts.sort()                           # sort 

        self.series_system = series_system                   # store series system to access for later functions
        self.system =  current_system                        # current system (possibly having parallel parts added)
        self.num_Parallels_added = count_Prev_Parallels      # placeholder Parameters
        
        self.store_elements()
        self.save_all_R_ts()
         
           
       
    
    def store_elements(self):
        
        # grab info from self
        series_sys = self.series_system
        parallel_assignments = self.parallel_parts
        
        #call function to define name of this parallel part
        self.define_comp_name(parallel_assignments)
               
       # mark the components as added so they can be skipped later
        for assignment in parallel_assignments:
            series_sys[assignment-1].parallel== True
            series_sys[assignment-1].added_in_parallel = True   
        self.series_system = series_sys

        
                
                
    def define_comp_name(self, parallel_list):
        
        # set the name of the part based on which parts are included
        num_parts= len(parallel_list)                  # number of parts in the parallel set

        begin_name= f'Parts '
        middle_name= f'{parallel_list[0]}'      
        for i in range(num_parts-1):
            middle_name= middle_name + ',' + f'{parallel_list[i+1]}'
        end_name = f' in Parallel'
    
        name= f'{begin_name + middle_name + end_name}'
        self.objName = name
            
            
        
        
            
                       
    def save_all_R_ts(self):
        
        # grab info from self        
        series_sys = self.series_system
        parallel_assignments = self.parallel_parts
        num_parts = len(parallel_assignments)  
              
        # grab each R_t for the series comps to be considered in parallel
        num_samples = series_sys[0].sample_size
        series_ts= np.zeros(( num_parts, num_samples ))                          # placeholder for each comp_R_t over lookup
        series_R_ts= np.empty_like(series_ts)
   
        for i, assignment in enumerate(parallel_assignments):
            series_R_ts[i], series_ts[i]= series_sys[assignment-1].R_t , series_sys[assignment-1].t
        
        # determine parallel Reliability   
        self.OR_Logic(series_R_ts, series_ts)                      
        
    
    
    

    
    def OR_Logic(self, series_R_ts, series_ts):
        '''
        this function will complete the mathematical operations to 
        consider all individual series reliabilites in parallel
                    
                OR Logic
                    - probability of at least one component in parallel still being functional 
                    - (prob comp1 has failed) * (prob comp2 has failed) * (prob comp3 has failed) * ...
                    - (1-R1) * (1-R2) * (1-R3) * ... 
            
        Parameters
        --------------------------------------------------------------------
        1. lookup_times: numpy array of values
            times at which the composite (parallel ) reliability is desired,
            need not be equal to failure times generated by the reliability curves
             
        Returns
        -------------------------------------------------------------------
        1. parallel_R_t:  list of floats
            the calculated overall distrubution of the parallel components over the given lookuptimes    
        '''
        
        # determine final parallel reliability as a probability of all part being failed
        num_samples = len(series_R_ts[0]) 
        
        # save times as the maximum time at each time step / sample point
        parallel_ts = np.zeros((num_samples))
        index= np.argmax(series_ts, 0)
        for i in range(num_samples):
            parallel_ts[i] = series_ts[index[i],i]
        self.t = parallel_ts 
        
        # save relaibility using or_logic
        finalParallelRel = [1 for val in range(num_samples)]                      # set value equal to 1 at first
        for i in range(num_samples):                                              # iterate through all lookuptimes 
            factor = 1
            for j in range(len(series_R_ts)):                                     # consider all components in parallel set at that lookup time                
                factor *= 1-series_R_ts[j][i]                                     # multiply all component reliabilities
            finalParallelRel[i]= finalParallelRel[i] - factor    
        self.R_t = finalParallelRel

               



    def get_lookup_R_t(self,lookup_times):
        lookup_R_t, lookup_t = calc.find_lookup_R_t(self.R_t, self.t, lookup_times)
        self.lookup_R_t, self.lookup_t=  lookup_R_t, lookup_t




    def determine_Failure_T(self, num_realization):
        '''
        Parameters
        -------------------------------------------------------------------
        1.) num_realization: 
            the "failure instance" or "vessel number" to select from the randomly generated
            distribution of serial component failure times . 

        Return
        -------------------------------------------------------------------
        1.) fail_time: 
            the time of failure for the instance requested        
        '''
        
        parts= self.parallel_parts
        series_sys= self.series_system

        fail_times= [0 for i in range(len(parts))]
                
        # grab the failure time of the part in the parallel set 
        for i, comp_assignment in enumerate(parts):
            
            # grab a failure realization from the original random distribution
            series_comp= series_sys[comp_assignment-1]
            series_comp.determine_Failure_T(num_realization)
            fail_times[i] = series_comp.f_t

        # determine which part fails last
        parallel_f_t= max(fail_times)
        
        self.f_t = parallel_f_t